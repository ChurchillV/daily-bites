{"mappings":"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","sources":["packages/@react-stately/layout/src/index.ts","packages/@react-stately/layout/src/ListLayout.ts","packages/@react-stately/layout/src/TableLayout.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nexport type {ListLayoutOptions, LayoutNode} from './ListLayout';\nexport {ListLayout} from './ListLayout';\nexport {TableLayout} from './TableLayout';\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, DropTarget, DropTargetDelegate, KeyboardDelegate, Node} from '@react-types/shared';\nimport {getChildNodes} from '@react-stately/collections';\nimport {InvalidationContext, Layout, LayoutInfo, Point, Rect, Size} from '@react-stately/virtualizer';\nimport {Key} from 'react';\n// import { DragTarget, DropTarget, DropPosition } from '@react-types/shared';\n\nexport type ListLayoutOptions<T> = {\n  /** The height of a row in px. */\n  rowHeight?: number,\n  estimatedRowHeight?: number,\n  headingHeight?: number,\n  estimatedHeadingHeight?: number,\n  padding?: number,\n  indentationForItem?: (collection: Collection<Node<T>>, key: Key) => number,\n  collator?: Intl.Collator,\n  loaderHeight?: number,\n  placeholderHeight?: number,\n  allowDisabledKeyFocus?: boolean\n};\n\n// A wrapper around LayoutInfo that supports hierarchy\nexport interface LayoutNode {\n  node?: Node<unknown>,\n  layoutInfo: LayoutInfo,\n  header?: LayoutInfo,\n  children?: LayoutNode[],\n  validRect: Rect,\n  index?: number\n}\n\nconst DEFAULT_HEIGHT = 48;\n\n/**\n * The ListLayout class is an implementation of a collection view {@link Layout}\n * it is used for creating lists and lists with indented sub-lists.\n *\n * To configure a ListLayout, you can use the properties to define the\n * layouts and/or use the method for defining indentation.\n * The {@link ListKeyboardDelegate} extends the existing collection view\n * delegate with an additional method to do this (it uses the same delegate object as\n * the collection view itself).\n */\nexport class ListLayout<T> extends Layout<Node<T>> implements KeyboardDelegate, DropTargetDelegate {\n  protected rowHeight: number;\n  protected estimatedRowHeight: number;\n  protected headingHeight: number;\n  protected estimatedHeadingHeight: number;\n  protected padding: number;\n  protected indentationForItem?: (collection: Collection<Node<T>>, key: Key) => number;\n  protected layoutInfos: Map<Key, LayoutInfo>;\n  protected layoutNodes: Map<Key, LayoutNode>;\n  protected contentSize: Size;\n  collection: Collection<Node<T>>;\n  disabledKeys: Set<Key> = new Set();\n  allowDisabledKeyFocus: boolean = false;\n  isLoading: boolean;\n  protected lastWidth: number;\n  protected lastCollection: Collection<Node<T>>;\n  protected rootNodes: LayoutNode[];\n  protected collator: Intl.Collator;\n  protected invalidateEverything: boolean;\n  protected loaderHeight: number;\n  protected placeholderHeight: number;\n  protected lastValidRect: Rect;\n  protected validRect: Rect;\n\n  /**\n   * Creates a new ListLayout with options. See the list of properties below for a description\n   * of the options that can be provided.\n   */\n  constructor(options: ListLayoutOptions<T> = {}) {\n    super();\n    this.rowHeight = options.rowHeight;\n    this.estimatedRowHeight = options.estimatedRowHeight;\n    this.headingHeight = options.headingHeight;\n    this.estimatedHeadingHeight = options.estimatedHeadingHeight;\n    this.padding = options.padding || 0;\n    this.indentationForItem = options.indentationForItem;\n    this.collator = options.collator;\n    this.loaderHeight = options.loaderHeight;\n    this.placeholderHeight = options.placeholderHeight;\n    this.layoutInfos = new Map();\n    this.layoutNodes = new Map();\n    this.rootNodes = [];\n    this.lastWidth = 0;\n    this.lastCollection = null;\n    this.allowDisabledKeyFocus = options.allowDisabledKeyFocus;\n    this.lastValidRect = new Rect();\n    this.validRect = new Rect();\n    this.contentSize = new Size();\n  }\n\n  getLayoutInfo(key: Key) {\n    let res = this.layoutInfos.get(key);\n\n    // If the layout info wasn't found, it might be outside the bounds of the area that we've\n    // computed layout for so far. This can happen when accessing a random key, e.g pressing Home/End.\n    // Compute the full layout and try again.\n    if (!res && this.validRect.area < this.contentSize.area && this.lastCollection) {\n      this.lastValidRect = this.validRect;\n      this.validRect = new Rect(0, 0, Infinity, Infinity);\n      this.rootNodes = this.buildCollection();\n      this.validRect = new Rect(0, 0, this.contentSize.width, this.contentSize.height);\n      res = this.layoutInfos.get(key);\n    }\n\n    return res;\n  }\n\n  getVisibleLayoutInfos(rect: Rect) {\n    // If layout hasn't yet been done for the requested rect, union the\n    // new rect with the existing valid rect, and recompute.\n    if (!this.validRect.containsRect(rect) && this.lastCollection) {\n      this.lastValidRect = this.validRect;\n      this.validRect = this.validRect.union(rect);\n      this.rootNodes = this.buildCollection();\n    }\n\n    let res: LayoutInfo[] = [];\n\n    let addNodes = (nodes: LayoutNode[]) => {\n      for (let node of nodes) {\n        if (this.isVisible(node, rect)) {\n          res.push(node.layoutInfo);\n          if (node.header) {\n            res.push(node.header);\n          }\n\n          if (node.children) {\n            addNodes(node.children);\n          }\n        }\n      }\n    };\n\n    addNodes(this.rootNodes);\n    return res;\n  }\n\n  isVisible(node: LayoutNode, rect: Rect) {\n    return node.layoutInfo.rect.intersects(rect) || node.layoutInfo.isSticky || this.virtualizer.isPersistedKey(node.layoutInfo.key);\n  }\n\n  protected shouldInvalidateEverything(invalidationContext: InvalidationContext<Node<T>, unknown>) {\n    // Invalidate cache if the size of the collection changed.\n    // In this case, we need to recalculate the entire layout.\n    return invalidationContext.sizeChanged;\n  }\n\n  validate(invalidationContext: InvalidationContext<Node<T>, unknown>) {\n    this.collection = this.virtualizer.collection;\n\n    // Reset valid rect if we will have to invalidate everything.\n    // Otherwise we can reuse cached layout infos outside the current visible rect.\n    this.invalidateEverything = this.shouldInvalidateEverything(invalidationContext);\n    if (this.invalidateEverything) {\n      this.lastValidRect = this.validRect;\n      this.validRect = this.virtualizer.getVisibleRect();\n    }\n\n    this.rootNodes = this.buildCollection();\n\n    // Remove deleted layout nodes\n    if (this.lastCollection && this.collection !== this.lastCollection) {\n      for (let key of this.lastCollection.getKeys()) {\n        if (!this.collection.getItem(key)) {\n          let layoutNode = this.layoutNodes.get(key);\n          if (layoutNode) {\n            this.layoutInfos.delete(layoutNode.layoutInfo.key);\n            this.layoutInfos.delete(layoutNode.header?.key);\n            this.layoutNodes.delete(key);\n          }\n        }\n      }\n    }\n\n    this.lastWidth = this.virtualizer.visibleRect.width;\n    this.lastCollection = this.collection;\n    this.invalidateEverything = false;\n  }\n\n  buildCollection(): LayoutNode[] {\n    let y = this.padding;\n    let skipped = 0;\n    let nodes = [];\n    for (let node of this.collection) {\n      let rowHeight = (this.rowHeight ?? this.estimatedRowHeight);\n\n      // Skip rows before the valid rectangle unless they are already cached.\n      if (node.type === 'item' && y + rowHeight < this.validRect.y && !this.isValid(node, y)) {\n        y += rowHeight;\n        skipped++;\n        continue;\n      }\n\n      let layoutNode = this.buildChild(node, 0, y);\n      y = layoutNode.layoutInfo.rect.maxY;\n      nodes.push(layoutNode);\n\n      if (node.type === 'item' && y > this.validRect.maxY) {\n        y += (this.collection.size - (nodes.length + skipped)) * rowHeight;\n        break;\n      }\n    }\n\n    if (this.isLoading) {\n      let rect = new Rect(0, y, this.virtualizer.visibleRect.width,\n        this.loaderHeight ?? this.virtualizer.visibleRect.height);\n      let loader = new LayoutInfo('loader', 'loader', rect);\n      this.layoutInfos.set('loader', loader);\n      nodes.push({layoutInfo: loader});\n      y = loader.rect.maxY;\n    }\n\n    if (nodes.length === 0) {\n      let rect = new Rect(0, y, this.virtualizer.visibleRect.width,\n        this.placeholderHeight ?? this.virtualizer.visibleRect.height);\n      let placeholder = new LayoutInfo('placeholder', 'placeholder', rect);\n      this.layoutInfos.set('placeholder', placeholder);\n      nodes.push({layoutInfo: placeholder});\n      y = placeholder.rect.maxY;\n    }\n\n    this.contentSize = new Size(this.virtualizer.visibleRect.width, y + this.padding);\n    return nodes;\n  }\n\n  isValid(node: Node<T>, y: number) {\n    let cached = this.layoutNodes.get(node.key);\n    return (\n      !this.invalidateEverything &&\n      cached &&\n      cached.node === node &&\n      y === (cached.header || cached.layoutInfo).rect.y &&\n      cached.layoutInfo.rect.intersects(this.lastValidRect) &&\n      cached.validRect.containsRect(cached.layoutInfo.rect.intersection(this.validRect))\n    );\n  }\n\n  buildChild(node: Node<T>, x: number, y: number): LayoutNode {\n    if (this.isValid(node, y)) {\n      return this.layoutNodes.get(node.key);\n    }\n\n    let layoutNode = this.buildNode(node, x, y);\n    layoutNode.node = node;\n\n    layoutNode.layoutInfo.parentKey = node.parentKey ?? null;\n    this.layoutInfos.set(layoutNode.layoutInfo.key, layoutNode.layoutInfo);\n    if (layoutNode.header) {\n      this.layoutInfos.set(layoutNode.header.key, layoutNode.header);\n    }\n\n    this.layoutNodes.set(node.key, layoutNode);\n    return layoutNode;\n  }\n\n  buildNode(node: Node<T>, x: number, y: number): LayoutNode {\n    switch (node.type) {\n      case 'section':\n        return this.buildSection(node, x, y);\n      case 'item':\n        return this.buildItem(node, x, y);\n    }\n  }\n\n  buildSection(node: Node<T>, x: number, y: number): LayoutNode {\n    let width = this.virtualizer.visibleRect.width;\n    let rectHeight = this.headingHeight;\n    let isEstimated = false;\n\n    // If no explicit height is available, use an estimated height.\n    if (rectHeight == null) {\n      // If a previous version of this layout info exists, reuse its height.\n      // Mark as estimated if the size of the overall collection view changed,\n      // or the content of the item changed.\n      let previousLayoutNode = this.layoutNodes.get(node.key);\n      if (previousLayoutNode && previousLayoutNode.header) {\n        let curNode = this.collection.getItem(node.key);\n        let lastNode = this.lastCollection ? this.lastCollection.getItem(node.key) : null;\n        rectHeight = previousLayoutNode.header.rect.height;\n        isEstimated = width !== this.lastWidth || curNode !== lastNode || previousLayoutNode.header.estimatedSize;\n      } else {\n        rectHeight = (node.rendered ? this.estimatedHeadingHeight : 0);\n        isEstimated = true;\n      }\n    }\n\n    if (rectHeight == null) {\n      rectHeight = DEFAULT_HEIGHT;\n    }\n\n    let headerRect = new Rect(0, y, width, rectHeight);\n    let header = new LayoutInfo('header', node.key + ':header', headerRect);\n    header.estimatedSize = isEstimated;\n    header.parentKey = node.key;\n    y += header.rect.height;\n\n    let rect = new Rect(0, y, width, 0);\n    let layoutInfo = new LayoutInfo(node.type, node.key, rect);\n\n    let startY = y;\n    let skipped = 0;\n    let children = [];\n    for (let child of getChildNodes(node, this.collection)) {\n      let rowHeight = (this.rowHeight ?? this.estimatedRowHeight);\n\n      // Skip rows before the valid rectangle unless they are already cached.\n      if (y + rowHeight < this.validRect.y && !this.isValid(node, y)) {\n        y += rowHeight;\n        skipped++;\n        continue;\n      }\n\n      let layoutNode = this.buildChild(child, x, y);\n      y = layoutNode.layoutInfo.rect.maxY;\n      children.push(layoutNode);\n\n      if (y > this.validRect.maxY) {\n        // Estimate the remaining height for rows that we don't need to layout right now.\n        y += ([...getChildNodes(node, this.collection)].length - (children.length + skipped)) * rowHeight;\n        break;\n      }\n    }\n\n    rect.height = y - startY;\n\n    return {\n      header,\n      layoutInfo,\n      children,\n      validRect: layoutInfo.rect.intersection(this.validRect)\n    };\n  }\n\n  buildItem(node: Node<T>, x: number, y: number): LayoutNode {\n    let width = this.virtualizer.visibleRect.width;\n    let rectHeight = this.rowHeight;\n    let isEstimated = false;\n\n    // If no explicit height is available, use an estimated height.\n    if (rectHeight == null) {\n      // If a previous version of this layout info exists, reuse its height.\n      // Mark as estimated if the size of the overall collection view changed,\n      // or the content of the item changed.\n      let previousLayoutNode = this.layoutNodes.get(node.key);\n      if (previousLayoutNode) {\n        rectHeight = previousLayoutNode.layoutInfo.rect.height;\n        isEstimated = width !== this.lastWidth || node !== previousLayoutNode.node || previousLayoutNode.layoutInfo.estimatedSize;\n      } else {\n        rectHeight = this.estimatedRowHeight;\n        isEstimated = true;\n      }\n    }\n\n    if (rectHeight == null) {\n      rectHeight = DEFAULT_HEIGHT;\n    }\n\n    if (typeof this.indentationForItem === 'function') {\n      x += this.indentationForItem(this.collection, node.key) || 0;\n    }\n\n    let rect = new Rect(x, y, width - x, rectHeight);\n    let layoutInfo = new LayoutInfo(node.type, node.key, rect);\n    // allow overflow so the focus ring/selection ring can extend outside to overlap with the adjacent items borders\n    layoutInfo.allowOverflow = true;\n    layoutInfo.estimatedSize = isEstimated;\n    return {\n      layoutInfo,\n      validRect: layoutInfo.rect\n    };\n  }\n\n  updateItemSize(key: Key, size: Size) {\n    let layoutInfo = this.layoutInfos.get(key);\n    // If no layoutInfo, item has been deleted/removed.\n    if (!layoutInfo) {\n      return false;\n    }\n\n    layoutInfo.estimatedSize = false;\n    if (layoutInfo.rect.height !== size.height) {\n      // Copy layout info rather than mutating so that later caches are invalidated.\n      let newLayoutInfo = layoutInfo.copy();\n      newLayoutInfo.rect.height = size.height;\n      this.layoutInfos.set(key, newLayoutInfo);\n\n      // Invalidate layout for this layout node and all parents\n      this.updateLayoutNode(key, layoutInfo, newLayoutInfo);\n\n      let node = this.collection.getItem(layoutInfo.parentKey);\n      while (node) {\n        this.updateLayoutNode(node.key, layoutInfo, newLayoutInfo);\n        node = this.collection.getItem(node.parentKey);\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  updateLayoutNode(key: Key, oldLayoutInfo: LayoutInfo, newLayoutInfo: LayoutInfo) {\n    let n = this.layoutNodes.get(key);\n    if (n) {\n      // Invalidate by reseting validRect.\n      n.validRect = new Rect();\n\n      // Replace layout info in LayoutNode\n      if (n.header === oldLayoutInfo) {\n        n.header = newLayoutInfo;\n      } else if (n.layoutInfo === oldLayoutInfo) {\n        n.layoutInfo = newLayoutInfo;\n      }\n    }\n  }\n\n  getContentSize() {\n    return this.contentSize;\n  }\n\n  getKeyAbove(key: Key): Key | null {\n    let collection = this.collection;\n\n    key = collection.getKeyBefore(key);\n    while (key != null) {\n      let item = collection.getItem(key);\n      if (item.type === 'item' && (this.allowDisabledKeyFocus || !this.disabledKeys.has(item.key))) {\n        return key;\n      }\n\n      key = collection.getKeyBefore(key);\n    }\n  }\n\n  getKeyBelow(key: Key): Key | null {\n    let collection = this.collection;\n\n    key = collection.getKeyAfter(key);\n    while (key != null) {\n      let item = collection.getItem(key);\n      if (item.type === 'item' && (this.allowDisabledKeyFocus || !this.disabledKeys.has(item.key))) {\n        return key;\n      }\n\n      key = collection.getKeyAfter(key);\n    }\n  }\n\n  getKeyPageAbove(key: Key): Key | null {\n    let layoutInfo = this.getLayoutInfo(key);\n\n    if (layoutInfo) {\n      let pageY = Math.max(0, layoutInfo.rect.y + layoutInfo.rect.height - this.virtualizer.visibleRect.height);\n      while (layoutInfo && layoutInfo.rect.y > pageY) {\n        let keyAbove = this.getKeyAbove(layoutInfo.key);\n        layoutInfo = this.getLayoutInfo(keyAbove);\n      }\n\n      if (layoutInfo) {\n        return layoutInfo.key;\n      }\n    }\n\n    return this.getFirstKey();\n  }\n\n  getKeyPageBelow(key: Key): Key | null {\n    let layoutInfo = this.getLayoutInfo(key != null ? key : this.getFirstKey());\n\n    if (layoutInfo) {\n      let pageY = Math.min(this.virtualizer.contentSize.height, layoutInfo.rect.y - layoutInfo.rect.height + this.virtualizer.visibleRect.height);\n      while (layoutInfo && layoutInfo.rect.y < pageY) {\n        let keyBelow = this.getKeyBelow(layoutInfo.key);\n        layoutInfo = this.getLayoutInfo(keyBelow);\n      }\n\n      if (layoutInfo) {\n        return layoutInfo.key;\n      }\n    }\n\n    return this.getLastKey();\n  }\n\n  getFirstKey(): Key | null {\n    let collection = this.collection;\n    let key = collection.getFirstKey();\n    while (key != null) {\n      let item = collection.getItem(key);\n      if (item.type === 'item' && (this.allowDisabledKeyFocus || !this.disabledKeys.has(item.key))) {\n        return key;\n      }\n\n      key = collection.getKeyAfter(key);\n    }\n  }\n\n  getLastKey(): Key | null {\n    let collection = this.collection;\n    let key = collection.getLastKey();\n    while (key != null) {\n      let item = collection.getItem(key);\n      if (item.type === 'item' && (this.allowDisabledKeyFocus || !this.disabledKeys.has(item.key))) {\n        return key;\n      }\n\n      key = collection.getKeyBefore(key);\n    }\n  }\n\n  getKeyForSearch(search: string, fromKey?: Key): Key | null {\n    if (!this.collator) {\n      return null;\n    }\n\n    let collection = this.collection;\n    let key = fromKey || this.getFirstKey();\n    while (key != null) {\n      let item = collection.getItem(key);\n      let substring = item.textValue.slice(0, search.length);\n      if (item.textValue && this.collator.compare(substring, search) === 0) {\n        return key;\n      }\n\n      key = this.getKeyBelow(key);\n    }\n\n    return null;\n  }\n\n  getInitialLayoutInfo(layoutInfo: LayoutInfo) {\n    layoutInfo.opacity = 0;\n    layoutInfo.transform = 'scale3d(0.8, 0.8, 0.8)';\n    return layoutInfo;\n  }\n\n  getFinalLayoutInfo(layoutInfo: LayoutInfo) {\n    layoutInfo.opacity = 0;\n    layoutInfo.transform = 'scale3d(0.8, 0.8, 0.8)';\n    return layoutInfo;\n  }\n\n  getDropTargetFromPoint(x: number, y: number, isValidDropTarget: (target: DropTarget) => boolean): DropTarget {\n    x += this.virtualizer.visibleRect.x;\n    y += this.virtualizer.visibleRect.y;\n\n    let key = this.virtualizer.keyAtPoint(new Point(x, y));\n    if (key == null || this.collection.size === 0) {\n      return {type: 'root'};\n    }\n\n    let layoutInfo = this.getLayoutInfo(key);\n    let rect = layoutInfo.rect;\n    let target: DropTarget = {\n      type: 'item',\n      key: layoutInfo.key,\n      dropPosition: 'on'\n    };\n\n    // If dropping on the item isn't accepted, try the target before or after depending on the y position.\n    // Otherwise, if dropping on the item is accepted, still try the before/after positions if within 10px\n    // of the top or bottom of the item.\n    if (!isValidDropTarget(target)) {\n      if (y <= rect.y + rect.height / 2 && isValidDropTarget({...target, dropPosition: 'before'})) {\n        target.dropPosition = 'before';\n      } else if (isValidDropTarget({...target, dropPosition: 'after'})) {\n        target.dropPosition = 'after';\n      }\n    } else if (y <= rect.y + 10 && isValidDropTarget({...target, dropPosition: 'before'})) {\n      target.dropPosition = 'before';\n    } else if (y >= rect.maxY - 10 && isValidDropTarget({...target, dropPosition: 'after'})) {\n      target.dropPosition = 'after';\n    }\n\n    return target;\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {ColumnSize, TableCollection} from '@react-types/table';\nimport {DropTarget, Node} from '@react-types/shared';\nimport {getChildNodes} from '@react-stately/collections';\nimport {GridNode} from '@react-types/grid';\nimport {InvalidationContext, LayoutInfo, Point, Rect, Size} from '@react-stately/virtualizer';\nimport {Key} from 'react';\nimport {LayoutNode, ListLayout, ListLayoutOptions} from './ListLayout';\nimport {TableColumnLayout} from '@react-stately/table';\n\ntype TableLayoutOptions<T> = ListLayoutOptions<T> & {\n  columnLayout: TableColumnLayout<T>,\n  initialCollection: TableCollection<T>\n}\n\nexport class TableLayout<T> extends ListLayout<T> {\n  collection: TableCollection<T>;\n  lastCollection: TableCollection<T>;\n  columnWidths: Map<Key, number> = new Map();\n  stickyColumnIndices: number[];\n  wasLoading = false;\n  isLoading = false;\n  lastPersistedKeys: Set<Key> = null;\n  persistedIndices: Map<Key, number[]> = new Map();\n  private disableSticky: boolean;\n  columnLayout: TableColumnLayout<T>;\n  controlledColumns: Map<Key, GridNode<unknown>>;\n  uncontrolledColumns: Map<Key, GridNode<unknown>>;\n  uncontrolledWidths: Map<Key, ColumnSize>;\n  resizingColumn: Key | null;\n\n  constructor(options: TableLayoutOptions<T>) {\n    super(options);\n    this.collection = options.initialCollection;\n    this.stickyColumnIndices = [];\n    this.disableSticky = this.checkChrome105();\n    this.columnLayout = options.columnLayout;\n    let [controlledColumns, uncontrolledColumns] = this.columnLayout.splitColumnsIntoControlledAndUncontrolled(this.collection.columns);\n    this.controlledColumns = controlledColumns;\n    this.uncontrolledColumns = uncontrolledColumns;\n    this.uncontrolledWidths = this.columnLayout.getInitialUncontrolledWidths(uncontrolledColumns);\n  }\n\n  protected shouldInvalidateEverything(invalidationContext: InvalidationContext<Node<T>, unknown>): boolean {\n    // If columns changed, clear layout cache.\n    return super.shouldInvalidateEverything(invalidationContext) || (\n      !this.lastCollection ||\n      this.collection.columns.length !== this.lastCollection.columns.length ||\n      this.collection.columns.some((c, i) =>\n        c.key !== this.lastCollection.columns[i].key ||\n        c.props.width !== this.lastCollection.columns[i].props.width ||\n        c.props.minWidth !== this.lastCollection.columns[i].props.minWidth ||\n        c.props.maxWidth !== this.lastCollection.columns[i].props.maxWidth\n      )\n    );\n  }\n\n  getResizerPosition(): Key {\n    return this.getLayoutInfo(this.resizingColumn)?.rect.maxX;\n  }\n\n  getColumnWidth(key: Key): number {\n    return this.columnLayout.getColumnWidth(key) ?? 0;\n  }\n\n  getColumnMinWidth(key: Key): number {\n    let column = this.collection.columns.find(col => col.key === key);\n    if (!column) {\n      return 0;\n    }\n    return this.columnLayout.getColumnMinWidth(key);\n  }\n\n  getColumnMaxWidth(key: Key): number {\n    let column = this.collection.columns.find(col => col.key === key);\n    if (!column) {\n      return 0;\n    }\n    return this.columnLayout.getColumnMaxWidth(key);\n  }\n\n  // outside, where this is called, should call props.onColumnResizeStart...\n  startResize(key: Key): void {\n    this.resizingColumn = key;\n  }\n\n  // only way to call props.onColumnResize with the new size outside of Layout is to send the result back\n  updateResizedColumns(key: Key, width: number): Map<Key, ColumnSize> {\n    let newControlled = new Map(Array.from(this.controlledColumns).map(([key, entry]) => [key, entry.props.width]));\n    let newSizes = this.columnLayout.resizeColumnWidth(this.virtualizer.visibleRect.width, this.collection, newControlled, this.uncontrolledWidths, key, width);\n\n    let map = new Map(Array.from(this.uncontrolledColumns).map(([key]) => [key, newSizes.get(key)]));\n    map.set(key, width);\n    this.uncontrolledWidths = map;\n    // relayoutNow still uses setState, should happen at the same time the parent\n    // component's state is processed as a result of props.onColumnResize\n    if (this.uncontrolledWidths.size > 0) {\n      this.virtualizer.relayoutNow({sizeChanged: true});\n    }\n    return newSizes;\n  }\n\n  endResize(): void {\n    this.resizingColumn = null;\n  }\n\n  buildCollection(): LayoutNode[] {\n    // Track whether we were previously loading. This is used to adjust the animations of async loading vs inserts.\n    let loadingState = this.collection.body.props.loadingState;\n    this.wasLoading = this.isLoading;\n    this.isLoading = loadingState === 'loading' || loadingState === 'loadingMore';\n    this.stickyColumnIndices = [];\n\n    for (let column of this.collection.columns) {\n      // The selection cell and any other sticky columns always need to be visible.\n      // In addition, row headers need to be in the DOM for accessibility labeling.\n      if (column.props.isDragButtonCell || column.props.isSelectionCell || this.collection.rowHeaderColumnKeys.has(column.key)) {\n        this.stickyColumnIndices.push(column.index);\n      }\n    }\n\n    let [controlledColumns, uncontrolledColumns] = this.columnLayout.splitColumnsIntoControlledAndUncontrolled(this.collection.columns);\n    this.controlledColumns = controlledColumns;\n    this.uncontrolledColumns = uncontrolledColumns;\n    let colWidths = this.columnLayout.recombineColumns(this.collection.columns, this.uncontrolledWidths, uncontrolledColumns, controlledColumns);\n\n    this.columnWidths = this.columnLayout.buildColumnWidths(this.virtualizer.visibleRect.width, this.collection, colWidths);\n\n    let header = this.buildHeader();\n    let body = this.buildBody(0);\n    this.lastPersistedKeys = null;\n\n    body.layoutInfo.rect.width = Math.max(header.layoutInfo.rect.width, body.layoutInfo.rect.width);\n    this.contentSize = new Size(body.layoutInfo.rect.width, body.layoutInfo.rect.maxY);\n    return [\n      header,\n      body\n    ];\n  }\n\n  buildHeader(): LayoutNode {\n    let rect = new Rect(0, 0, 0, 0);\n    let layoutInfo = new LayoutInfo('header', 'header', rect);\n\n    let y = 0;\n    let width = 0;\n    let children: LayoutNode[] = [];\n    for (let headerRow of this.collection.headerRows) {\n      let layoutNode = this.buildChild(headerRow, 0, y);\n      layoutNode.layoutInfo.parentKey = 'header';\n      y = layoutNode.layoutInfo.rect.maxY;\n      width = Math.max(width, layoutNode.layoutInfo.rect.width);\n      layoutNode.index = children.length;\n      children.push(layoutNode);\n    }\n\n    rect.width = width;\n    rect.height = y;\n\n    this.layoutInfos.set('header', layoutInfo);\n\n    return {\n      layoutInfo,\n      children,\n      validRect: layoutInfo.rect\n    };\n  }\n\n  buildHeaderRow(headerRow: GridNode<T>, x: number, y: number): LayoutNode {\n    let rect = new Rect(0, y, 0, 0);\n    let row = new LayoutInfo('headerrow', headerRow.key, rect);\n\n    let height = 0;\n    let columns: LayoutNode[] = [];\n    for (let cell of getChildNodes(headerRow, this.collection)) {\n      let layoutNode = this.buildChild(cell, x, y);\n      layoutNode.layoutInfo.parentKey = row.key;\n      x = layoutNode.layoutInfo.rect.maxX;\n      height = Math.max(height, layoutNode.layoutInfo.rect.height);\n      layoutNode.index = columns.length;\n      columns.push(layoutNode);\n    }\n    for (let [i, layout] of columns.entries()) {\n      layout.layoutInfo.zIndex = columns.length - i + 1;\n    }\n\n    this.setChildHeights(columns, height);\n\n    rect.height = height;\n    rect.width = x;\n\n    return {\n      layoutInfo: row,\n      children: columns,\n      validRect: rect\n    };\n  }\n\n  setChildHeights(children: LayoutNode[], height: number) {\n    for (let child of children) {\n      if (child.layoutInfo.rect.height !== height) {\n        // Need to copy the layout info before we mutate it.\n        child.layoutInfo = child.layoutInfo.copy();\n        this.layoutInfos.set(child.layoutInfo.key, child.layoutInfo);\n\n        child.layoutInfo.rect.height = height;\n      }\n    }\n  }\n\n  // used to get the column widths when rendering to the DOM\n  getRenderedColumnWidth(node: GridNode<T>) {\n    let colspan = node.colspan ?? 1;\n    let colIndex = node.colIndex ?? node.index;\n    let width = 0;\n    for (let i = colIndex; i < colIndex + colspan; i++) {\n      let column = this.collection.columns[i];\n      if (column?.key != null) {\n        width += this.columnWidths.get(column.key);\n      }\n    }\n\n    return width;\n  }\n\n  getEstimatedHeight(node: GridNode<T>, width: number, height: number, estimatedHeight: number) {\n    let isEstimated = false;\n\n    // If no explicit height is available, use an estimated height.\n    if (height == null) {\n      // If a previous version of this layout info exists, reuse its height.\n      // Mark as estimated if the size of the overall collection view changed,\n      // or the content of the item changed.\n      let previousLayoutNode = this.layoutNodes.get(node.key);\n      if (previousLayoutNode) {\n        height = previousLayoutNode.layoutInfo.rect.height;\n        isEstimated = node !== previousLayoutNode.node || width !== previousLayoutNode.layoutInfo.rect.width || previousLayoutNode.layoutInfo.estimatedSize;\n      } else {\n        height = estimatedHeight;\n        isEstimated = true;\n      }\n    }\n\n    return {height, isEstimated};\n  }\n\n  buildColumn(node: GridNode<T>, x: number, y: number): LayoutNode {\n    let width = this.getRenderedColumnWidth(node);\n    let {height, isEstimated} = this.getEstimatedHeight(node, width, this.headingHeight, this.estimatedHeadingHeight);\n    let rect = new Rect(x, y, width, height);\n    let layoutInfo = new LayoutInfo(node.type, node.key, rect);\n    layoutInfo.isSticky = !this.disableSticky && (node.props?.isDragButtonCell || node.props?.isSelectionCell);\n    layoutInfo.zIndex = layoutInfo.isSticky ? 2 : 1;\n    layoutInfo.estimatedSize = isEstimated;\n\n    return {\n      layoutInfo,\n      validRect: layoutInfo.rect\n    };\n  }\n\n  buildBody(y: number): LayoutNode {\n    let rect = new Rect(0, y, 0, 0);\n    let layoutInfo = new LayoutInfo('rowgroup', 'body', rect);\n\n    let startY = y;\n    let skipped = 0;\n    let width = 0;\n    let children: LayoutNode[] = [];\n    for (let [i, node] of [...this.collection].entries()) {\n      let rowHeight = (this.rowHeight ?? this.estimatedRowHeight) + 1;\n\n      // Skip rows before the valid rectangle unless they are already cached.\n      if (y + rowHeight < this.validRect.y && !this.isValid(node, y)) {\n        y += rowHeight;\n        skipped++;\n        continue;\n      }\n\n      let layoutNode = this.buildChild(node, 0, y);\n      layoutNode.layoutInfo.parentKey = 'body';\n      layoutNode.index = i;\n      y = layoutNode.layoutInfo.rect.maxY;\n      width = Math.max(width, layoutNode.layoutInfo.rect.width);\n      children.push(layoutNode);\n\n      if (y > this.validRect.maxY) {\n        // Estimate the remaining height for rows that we don't need to layout right now.\n        y += (this.collection.size - (skipped + children.length)) * rowHeight;\n        break;\n      }\n    }\n\n    if (this.isLoading) {\n      // Add some margin around the loader to ensure that scrollbars don't flicker in and out.\n      let rect = new Rect(40,  Math.max(y, 40), (width || this.virtualizer.visibleRect.width) - 80, children.length === 0 ? this.virtualizer.visibleRect.height - 80 : 60);\n      let loader = new LayoutInfo('loader', 'loader', rect);\n      loader.parentKey = 'body';\n      loader.isSticky = !this.disableSticky && children.length === 0;\n      this.layoutInfos.set('loader', loader);\n      children.push({layoutInfo: loader, validRect: loader.rect});\n      y = loader.rect.maxY;\n      width = Math.max(width, rect.width);\n    } else if (children.length === 0) {\n      let rect = new Rect(40, Math.max(y, 40), this.virtualizer.visibleRect.width - 80, this.virtualizer.visibleRect.height - 80);\n      let empty = new LayoutInfo('empty', 'empty', rect);\n      empty.parentKey = 'body';\n      empty.isSticky = !this.disableSticky;\n      this.layoutInfos.set('empty', empty);\n      children.push({layoutInfo: empty, validRect: empty.rect});\n      y = empty.rect.maxY;\n      width = Math.max(width, rect.width);\n    }\n\n    rect.width = width;\n    rect.height = y - startY;\n\n    this.layoutInfos.set('body', layoutInfo);\n\n    return {\n      layoutInfo,\n      children,\n      validRect: layoutInfo.rect.intersection(this.validRect)\n    };\n  }\n\n  buildNode(node: GridNode<T>, x: number, y: number): LayoutNode {\n    switch (node.type) {\n      case 'headerrow':\n        return this.buildHeaderRow(node, x, y);\n      case 'item':\n        return this.buildRow(node, x, y);\n      case 'column':\n      case 'placeholder':\n        return this.buildColumn(node, x, y);\n      case 'cell':\n        return this.buildCell(node, x, y);\n      default:\n        throw new Error('Unknown node type ' + node.type);\n    }\n  }\n\n  buildRow(node: GridNode<T>, x: number, y: number): LayoutNode {\n    let rect = new Rect(x, y, 0, 0);\n    let layoutInfo = new LayoutInfo('row', node.key, rect);\n\n    let children: LayoutNode[] = [];\n    let height = 0;\n    for (let [i, child] of [...getChildNodes(node, this.collection)].entries()) {\n      if (child.type === 'cell') {\n        if (x > this.validRect.maxX) {\n          // Adjust existing cached layoutInfo to ensure that it is out of view.\n          // This can happen due to column resizing.\n          let layoutNode = this.layoutNodes.get(child.key);\n          if (layoutNode) {\n            layoutNode.layoutInfo.rect.x = x;\n            x += layoutNode.layoutInfo.rect.width;\n          }\n        } else {\n          let layoutNode = this.buildChild(child, x, y);\n          x = layoutNode.layoutInfo.rect.maxX;\n          height = Math.max(height, layoutNode.layoutInfo.rect.height);\n          layoutNode.index = i;\n          children.push(layoutNode);\n        }\n      }\n    }\n\n    this.setChildHeights(children, height);\n\n    rect.width = this.layoutInfos.get('header').rect.width;\n    rect.height = height + 1; // +1 for bottom border\n\n    return {\n      layoutInfo,\n      children,\n      validRect: rect.intersection(this.validRect)\n    };\n  }\n\n  buildCell(node: GridNode<T>, x: number, y: number): LayoutNode {\n    let width = this.getRenderedColumnWidth(node);\n    let {height, isEstimated} = this.getEstimatedHeight(node, width, this.rowHeight, this.estimatedRowHeight);\n    let rect = new Rect(x, y, width, height);\n    let layoutInfo = new LayoutInfo(node.type, node.key, rect);\n    layoutInfo.isSticky = !this.disableSticky && (node.props?.isDragButtonCell || node.props?.isSelectionCell);\n    layoutInfo.zIndex = layoutInfo.isSticky ? 2 : 1;\n    layoutInfo.estimatedSize = isEstimated;\n\n    return {\n      layoutInfo,\n      validRect: rect\n    };\n  }\n\n  getVisibleLayoutInfos(rect: Rect) {\n    // If layout hasn't yet been done for the requested rect, union the\n    // new rect with the existing valid rect, and recompute.\n    if (!this.validRect.containsRect(rect) && this.lastCollection) {\n      this.lastValidRect = this.validRect;\n      this.validRect = this.validRect.union(rect);\n      this.rootNodes = this.buildCollection();\n    }\n\n    let res: LayoutInfo[] = [];\n\n    this.buildPersistedIndices();\n    for (let node of this.rootNodes) {\n      res.push(node.layoutInfo);\n      this.addVisibleLayoutInfos(res, node, rect);\n    }\n\n    return res;\n  }\n\n  addVisibleLayoutInfos(res: LayoutInfo[], node: LayoutNode, rect: Rect) {\n    if (!node.children || node.children.length === 0) {\n      return;\n    }\n\n    switch (node.layoutInfo.type) {\n      case 'header': {\n        for (let child of node.children) {\n          res.push(child.layoutInfo);\n          this.addVisibleLayoutInfos(res, child, rect);\n        }\n        break;\n      }\n      case 'rowgroup': {\n        let firstVisibleRow = this.binarySearch(node.children, rect.topLeft, 'y');\n        let lastVisibleRow = this.binarySearch(node.children, rect.bottomRight, 'y');\n\n        // Add persisted rows before the visible rows.\n        let persistedRowIndices = this.persistedIndices.get(node.layoutInfo.key);\n        let persistIndex = 0;\n        while (\n          persistedRowIndices &&\n          persistIndex < persistedRowIndices.length &&\n          persistedRowIndices[persistIndex] < firstVisibleRow\n        ) {\n          let idx = persistedRowIndices[persistIndex];\n          if (idx < node.children.length) {\n            res.push(node.children[idx].layoutInfo);\n            this.addVisibleLayoutInfos(res, node.children[idx], rect);\n          }\n          persistIndex++;\n        }\n\n        for (let i = firstVisibleRow; i <= lastVisibleRow; i++) {\n          // Skip persisted rows that overlap with visible cells.\n          while (persistedRowIndices && persistIndex < persistedRowIndices.length && persistedRowIndices[persistIndex] < i) {\n            persistIndex++;\n          }\n\n          res.push(node.children[i].layoutInfo);\n          this.addVisibleLayoutInfos(res, node.children[i], rect);\n        }\n\n        // Add persisted rows after the visible rows.\n        while (persistedRowIndices && persistIndex < persistedRowIndices.length) {\n          let idx = persistedRowIndices[persistIndex++];\n          if (idx < node.children.length) {\n            res.push(node.children[idx].layoutInfo);\n          }\n        }\n        break;\n      }\n      case 'headerrow':\n      case 'row': {\n        let firstVisibleCell = this.binarySearch(node.children, rect.topLeft, 'x');\n        let lastVisibleCell = this.binarySearch(node.children, rect.topRight, 'x');\n        let stickyIndex = 0;\n\n        // Add persisted/sticky cells before the visible cells.\n        let persistedCellIndices = this.persistedIndices.get(node.layoutInfo.key) || this.stickyColumnIndices;\n        while (stickyIndex < persistedCellIndices.length && persistedCellIndices[stickyIndex] < firstVisibleCell) {\n          let idx = persistedCellIndices[stickyIndex];\n          if (idx < node.children.length) {\n            res.push(node.children[idx].layoutInfo);\n          }\n          stickyIndex++;\n        }\n\n        for (let i = firstVisibleCell; i <= lastVisibleCell; i++) {\n          // Skip sticky cells that overlap with visible cells.\n          while (stickyIndex < persistedCellIndices.length && persistedCellIndices[stickyIndex] < i) {\n            stickyIndex++;\n          }\n\n          res.push(node.children[i].layoutInfo);\n        }\n\n        // Add any remaining sticky cells after the visible cells.\n        while (stickyIndex < persistedCellIndices.length) {\n          let idx = persistedCellIndices[stickyIndex++];\n          if (idx < node.children.length) {\n            res.push(node.children[idx].layoutInfo);\n          }\n        }\n        break;\n      }\n      default:\n        throw new Error('Unknown node type ' + node.layoutInfo.type);\n    }\n  }\n\n  binarySearch(items: LayoutNode[], point: Point, axis: 'x' | 'y') {\n    let low = 0;\n    let high = items.length - 1;\n    while (low <= high) {\n      let mid = (low + high) >> 1;\n      let item = items[mid];\n\n      if ((axis === 'x' && item.layoutInfo.rect.maxX < point.x) || (axis === 'y' && item.layoutInfo.rect.maxY < point.y)) {\n        low = mid + 1;\n      } else if ((axis === 'x' && item.layoutInfo.rect.x > point.x) || (axis === 'y' && item.layoutInfo.rect.y > point.y)) {\n        high = mid - 1;\n      } else {\n        return mid;\n      }\n    }\n\n    return Math.max(0, Math.min(items.length - 1, low));\n  }\n\n  buildPersistedIndices() {\n    if (this.virtualizer.persistedKeys === this.lastPersistedKeys) {\n      return;\n    }\n\n    this.lastPersistedKeys = this.virtualizer.persistedKeys;\n    this.persistedIndices.clear();\n\n    // Build a map of parentKey => indices of children to persist.\n    for (let key of this.virtualizer.persistedKeys) {\n      let layoutInfo = this.layoutInfos.get(key);\n\n      // Walk up ancestors so parents are also persisted if children are.\n      while (layoutInfo && layoutInfo.parentKey) {\n        let collectionNode = this.collection.getItem(layoutInfo.key);\n        let indices = this.persistedIndices.get(layoutInfo.parentKey);\n        if (!indices) {\n          // stickyColumnIndices are always persisted along with any cells from persistedKeys.\n          indices = collectionNode.type === 'cell' || collectionNode.type === 'column' ? [...this.stickyColumnIndices] : [];\n          this.persistedIndices.set(layoutInfo.parentKey, indices);\n        }\n\n        let index = this.layoutNodes.get(layoutInfo.key).index;\n\n        if (!indices.includes(index)) {\n          indices.push(index);\n        }\n\n        layoutInfo = this.layoutInfos.get(layoutInfo.parentKey);\n      }\n    }\n\n    for (let indices of this.persistedIndices.values()) {\n      indices.sort((a, b) => a - b);\n    }\n  }\n\n  getInitialLayoutInfo(layoutInfo: LayoutInfo) {\n    let res = super.getInitialLayoutInfo(layoutInfo);\n    res.transform = null;\n    return res;\n  }\n\n  getFinalLayoutInfo(layoutInfo: LayoutInfo) {\n    let res = super.getFinalLayoutInfo(layoutInfo);\n    res.transform = null;\n    return res;\n  }\n\n  // Checks if Chrome version is 105 or greater\n  private checkChrome105() {\n    if (typeof window === 'undefined' || window.navigator == null) {\n      return false;\n    }\n\n    let isChrome105;\n    if (window.navigator['userAgentData']) {\n      isChrome105 = window.navigator['userAgentData']?.brands.some(b => b.brand === 'Chromium' && Number(b.version) === 105);\n    } else {\n      let regex = /Chrome\\/(\\d+)/;\n      let matches = regex.exec(window.navigator.userAgent);\n      isChrome105 = matches && matches.length >= 2 && Number(matches[1]) === 105;\n    }\n\n    return isChrome105;\n  }\n  getDropTargetFromPoint(x: number, y: number, isValidDropTarget: (target: DropTarget) => boolean): DropTarget {\n    x += this.virtualizer.visibleRect.x;\n    y += this.virtualizer.visibleRect.y;\n\n    // Offset for height of header row\n    y -= this.virtualizer.layout.getVisibleLayoutInfos(new Rect(x, y, 1, 1)).find(info => info.type === 'headerrow')?.rect.height;\n\n    // Custom variation of this.virtualizer.keyAtPoint that ignores body\n    let key: Key;\n    let point = new Point(x, y);\n    let rectAtPoint = new Rect(point.x, point.y, 1, 1);\n    let layoutInfos = this.virtualizer.layout.getVisibleLayoutInfos(rectAtPoint).filter(info => info.type === 'row');\n\n    // Layout may return multiple layout infos in the case of\n    // persisted keys, so find the first one that actually intersects.\n    for (let layoutInfo of layoutInfos) {\n      if (layoutInfo.rect.intersects(rectAtPoint)) {\n        key = layoutInfo.key;\n      }\n    }\n\n    if (key == null || this.collection.size === 0) {\n      return {type: 'root'};\n    }\n\n    let layoutInfo = this.getLayoutInfo(key);\n    let rect = layoutInfo.rect;\n    let target: DropTarget = {\n      type: 'item',\n      key: layoutInfo.key,\n      dropPosition: 'on'\n    };\n\n    // If dropping on the item isn't accepted, try the target before or after depending on the y position.\n    // Otherwise, if dropping on the item is accepted, still try the before/after positions if within 10px\n    // of the top or bottom of the item.\n    if (!isValidDropTarget(target)) {\n      if (y <= rect.y + rect.height / 2 && isValidDropTarget({...target, dropPosition: 'before'})) {\n        target.dropPosition = 'before';\n      } else if (isValidDropTarget({...target, dropPosition: 'after'})) {\n        target.dropPosition = 'after';\n      }\n    } else if (y <= rect.y + 10 && isValidDropTarget({...target, dropPosition: 'before'})) {\n      target.dropPosition = 'before';\n    } else if (y >= rect.maxY - 10 && isValidDropTarget({...target, dropPosition: 'after'})) {\n      target.dropPosition = 'after';\n    }\n\n    return target;\n  }\n}\n"],"names":[],"version":3,"file":"main.js.map"}